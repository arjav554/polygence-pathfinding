Comparative Analysis of Pathfinding Algorithms in High-Entropy EnvironmentsThis repository contains the source code and experimental data for a research project evaluating the performance of five distinct pathfinding algorithms. The study investigates the structural relationship between algorithmic performance (scalability, optimality) and environmental complexity (obstacle density, topology).ğŸ“Œ Project OverviewPathfinding is a fundamental problem in robotics and computer science. While A* is the industry standard, its performanceâ€”and that of its variantsâ€”fluctuates significantly depending on the map topology.This project simulates navigation in grid-based environments to answer specific research questions:How do Heuristic methods (A*, Greedy) compare to Blind methods (BFS, Dijkstra) as grid size scales exponentially?At what threshold of obstacle density does the optimization of Jump Point Search (JPS) degrade due to map fragmentation?What is the trade-off between speed and path optimality in Greedy Best-First Search?ğŸš€ Algorithms ImplementedThe repository includes Python implementations for the following algorithms:FileAlgorithmTypeDescriptionAstarRobot2.py*A (A-Star)**HeuristicThe standard for optimal pathfinding using $f(n) = g(n) + h(n)$.JPSRobot2.pyJump Point SearchOptimized HeuristicOptimization of A* that prunes symmetrical nodes to "jump" over open spaces.DijkstraRobot.pyDijkstra's AlgorithmBlindGuarantees the shortest path but explores uniformly in all directions.BFSRobot3.pyBreadth-First SearchBlindUnweighted search suitable for uniform cost grids; memory intensive.GreedyRobot.pyGreedy Best-FirstHeuristicPrioritizes speed by following the heuristic $h(n)$ exclusively; not guaranteed optimal.ğŸ“‚ Project StructureBashpolygence-pathfinding/
â”œâ”€â”€ AstarRobot2.py       # A* implementation and logging
â”œâ”€â”€ BFSRobot3.py         # BFS implementation
â”œâ”€â”€ DijkstraRobot.py     # Dijkstra implementation
â”œâ”€â”€ GreedyRobot.py       # Greedy Best-First implementation
â”œâ”€â”€ JPSRobot2.py         # Jump Point Search implementation
â”œâ”€â”€ pathfinding_experiments/ # Data logs and batch experiment scripts
â”œâ”€â”€ README.md            # Project documentation
â””â”€â”€ .gitignore           # Git configuration
ğŸ› ï¸ Installation & UsagePrerequisitesPython 3.8+Required libraries for analysis (optional, for plotting):Bashpip install pandas matplotlib seaborn
Running a SimulationEach "Robot" file is designed to run a simulation on a grid. You can execute them individually to test specific scenarios:Bash# Run the A* simulation
python AstarRobot2.py

# Run the Jump Point Search simulation
python JPSRobot2.py
Note: Check the __main__ block in each file to adjust grid size, start/end points, or obstacle density before running.ğŸ“Š Key Research FindingsBased on data collected from over 5,000 trials across grid sizes ranging from $64\times64$ to $512\times512$:The "JPS Threshold": JPS is the fastest algorithm in open fields and low-density maps (0â€“20% obstacles), often performing 5xâ€“10x faster than A*. However, in High Entropy (Maze) environments, its performance degrades to match or fall behind A* due to the overhead of jump-point calculations failing in fragmented spaces.Scalability Gap: Blind search methods (BFS, Dijkstra) exhibit exponential performance degradation on grids larger than $256\times256$, making them computationally unviable for large-scale real-time navigation.The Cost of Greed: Greedy Best-First Search consistently provided the fastest raw execution times (often near-instantaneous) but produced paths that were 10â€“25% suboptimal (longer) compared to A*.ğŸ“ˆ VisualizationsSample visualization of Search Space Efficiency (Log Scale)Heuristic methods (Blue/Purple) expand orders of magnitude fewer nodes than Blind methods (Orange/Green).(You can upload your Search Efficiency Distribution image here)
